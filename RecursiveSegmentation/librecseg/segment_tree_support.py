"""This file holds segment tree support classes
"""

LEAF_COMP_ERR = "New composition's leaf composition is not the same as the " \
                "nodes leaf composition"


class SegmentTreeNode(object):
    """Simple class to hold the necessary information for a node of the segment
    tree"""
    def __init__(self, func_name, is_simple, is_leaf):
        """Initialize the segment tree node with the name for the segment

        Parameters
        ----------
        is_simple : boolean
            Is this one of the leafs or sums of quartets or a custom sum
        func_name : str
            Name of the function in the root file
        """
        # each composition is a full set of nodes that add together to make
        # this particular segment. If this is a leaf node the compositions list
        # is left empty
        self.comps = []
        self.leaf_comp = set() if not is_leaf else set([func_name])
        self.parent = []
        self.adjacent_nodes = set()
        self.is_simple = is_simple
        self.function_name = func_name

    def add_adjacent_node(self, node):
        """Adds a node to the node list

        Parameters
        ----------
        node : SegmentTreeNode
            The tree node that is adjacent to this node
        """
        if len(node.leaf_comp) == 0:
            raise ValueError("Cannot add non-leaf node with no composition")
        self.adjacent_nodes |= node.leaf_comp

    def is_adjacent(self, test_node):
        """Checks if test_node is adjacent to, or contains any segments that
        are adjacent to this node or segments that are within this node

        Parameters
        ----------
        test_node : SegmentTreeNode
            The node whose adjacency needs to be tested

        Returns
        -------
        is_adjacent : bool
            True if test_node is adjacent to this node or contains segments
            that are adjacent to this node or are adjacent to segments within
            this node.
            False otherwise
        """
        if not self.adjacent_nodes.isdisjoint(test_node.leaf_comp):
            return True
        return False

    def build_adjacency(self):
        """Takes the given composition and builds its adjacency set from the
        adjacencies of the nodes that compose it minus the nodes that compose
        this node
        """
        for node in self.comps:
            self.adjacent_nodes |= node.adjacent_nodes
        self.adjacent_nodes -= self.leaf_comp

    def print_self_and_children(self, line_str, base_str):
        """Prints this node and its children in a visually reasonable manner
        via recursion

        Parameters
        ----------
        line_str : str
            string to prefix to the line for this node
        base_str : str
            string to prefix children compositions
        """
        # write the output for this node
        print (line_str +
               "{0:s}--^[{1:s}]".format(self.function_name,
                                        ",".join([x.function_name
                                                  for x in self.parent])))
        # write the output for the child compositions
        for i, comp in enumerate(self.comps):
            print base_str + "|-Composition# {0:d}".format(i)
            for seg in comp[0]:
                seg.print_self_and_children(base_str + "|---",
                                            base_str + "|   ")

    def add_composition(self, func_list):
        """Add a composition to a segment, a composition is a list of child
        SegmentTreeNodes

        Parameters
        ----------
        func_list : list
            list of SegmentTreeNodes
        """
        test_comp = set()
        for node in func_list:
            test_comp |= node.leaf_comp
        if len(self.leaf_comp) == 0:
            self.leaf_comp = test_comp
            self.comps.append(func_list)
        else:
            if self.leaf_comp != test_comp:
                raise ValueError(LEAF_COMP_ERR)
            else:
                self.comps.append(func_list)

    def add_parent(self, par_node):
        """Add the parent node for the node

        Parameters
        ----------
        par_node: SegmentTreeNode
            Parent node that links to this node
        """
        self.parent.append(par_node)

    def get_fun_name(self):
        """Return the segments function name

        Returns
        -------
        function_name : str
            The name of the function in the root file
        """
        return self.function_name

    def get_is_simple(self):
        """Gets if the segment is a simple piece generated by quartet summing
        or if it is one of the more complex sums in non even shapes

        Returns
        -------
        is_simple : bool
            True if the segment is one of the basic quartet summed or base
            segments, false otherwise
        """
        return self.is_simple

    def is_leaf(self):
        """Return if the segment is a leaf or not, i.e. does it have no child
        segments. If not it is at the bottom of the tree and is a child

        Returns
        -------
        function_name : str
            The name of the function in the root file
        """
        return len(self.comps) == 0


class SegmentInfo(object):
    """Class to hold information about the segment for the segment dictionary
    """
    def __init__(self, is_built, node_ref):
        """Initializes the segment information

        Parameters
        ----------
        is_built : boolean
            Is this function already existent within the root file
        node_ref : SegmentTreeNode
            The node representing this segment
        """
        self.is_built = is_built
        self.node_ref = node_ref

    def get_node(self):
        """Gets the node reference of the object

        Returns
        -------
        node_ref : SegmentTreeNode
            The segment tree node that represents the function
        """
        return self.node_ref

    def get_build_status(self):
        """Gets if the segment has been summed yet

        Returns
        -------
        build_status : bool
            True if the segment exists in the root file, false otherwise
        """
        return self.is_built


def gen_quartet_names(fmt_str, curr_segs, inds):
    """This function generates the 1 level of divisions down from what is
    passed to it

    Parameters
    ----------
    fmt_str : str
        The name generating format string
    curr_segs : int
        The segmentation at the current level
    inds : tuple
        A tuple of two integers holding the two current segment indices

    Returns
    -------
    seg_name_list : list of strings
        list of names of the 4 segments comprising the one passed to this func
    """
    seg_name_list = []
    off1 = 2*inds[0]
    off2 = 2*inds[1]
    for i in range(2):
        for j in range(2):
            seg_name_list.append(fmt_str.format(curr_segs*2,
                                                off1 + i, off2 + j))
    return seg_name_list
