"""This file holds segment tree support classes
"""


class SegmentTreeNode(object):
    """Simple class to hold the necessary information for a node of the segment
    tree"""
    def __init__(self, func_name, is_simple=False, segment_indices=None):
        """Initialize the segment tree node with the name for the segment

        Parameters
        ----------
        is_simple : boolean
            Is this one of the leafs or sums of quartets or a custom sum
        func_name : str
            Name of the function in the root file
        segment_indices : None or 3-tuple
            None if is_simple is false, otherwise must be a 3-tuple containing
            axis_segmentation, axis_index_1, axis_index_2
        """        
        if is_simple and segment_indices is None:
            raise TypeError("'segment_indices' is None when is_simple is true")
        # each composition is a full set of nodes that add together to make
        # this particular segment. If this is a leaf node the compositions list
        # is left empty
        self.comps = []
        self.parent = []
        self.is_simple = is_simple
        self.indices = segment_indices
        self.function_name = func_name

    def is_adjacent(self, test_node):
        """Checks if test_node is adjacent to, or contains any segments that
        are adjacent to this node or segments that are within this node

        Parameters
        ----------
        test_node : SegmentTreeNode
            The node whose adjacency needs to be tested

        Returns
        -------
        is_adjacent : bool
            True if test_node is adjacent to this node or contains segments
            that are adjacent to this node or are adjacent to segments within
            this node.
            False otherwise
        """
        # TODO: implement this, I am thinking basic checks then use a set
        return False

    def print_self_and_children(self, line_str, base_str):
        """Prints this node and its children in a visually reasonable manner
        via recursion"""
        # write the output
        print (line_str +
               "{0:s}--^[{1:s}]".format(self.function_name,
                                        ",".join([x.function_name
                                                  for x in self.parent])))
        for i, comp in enumerate(self.comps):
            print (base_str + "|-Composition# {0:d}".format(i))
            for seg in comp:
                seg.print_self_and_children(base_str + "|---",
                                            base_str + "|   ")

    def add_composition(self, func_list):
        """Add a composition to a segment, a composition is a list of child
        SegmentTreeNodes

        Parameters
        ----------
        func_list : list
            list of SegmentTreeNodes
        """
        self.comps.append(func_list)

    def add_parent(self, par_node):
        """Add the parent node for the node

        Parameters
        ----------
        par_node: SegmentTreeNode
            Parent node that links to this node
        """
        self.parent.append(par_node)

    def get_fun_name(self):
        """Return the segments function name

        Returns
        -------
        function_name : str
            The name of the function in the root file
        """
        return self.function_name

    def get_is_simple(self):
        """Gets if the segment is a simple piece generated by quartet summing
        or if it is one of the more complex sums in non even shapes

        Returns
        -------
        is_simple : bool
            True if the segment is one of the basic quartet summed or base
            segments, false otherwise
        """
        return self.is_simple

    def is_leaf(self):
        """Return if the segment is a leaf or not, i.e. does it have no child
        segments. If not it is at the bottom of the tree and is a child

        Returns
        -------
        function_name : str
            The name of the function in the root file
        """
        return len(self.comps) == 0


class SegmentInfo(object):
    """Class to hold information about the segment for the segment dictionary
    """
    def __init__(self, is_built, node_ref):
        """Initializes the segment information

        Parameters
        ----------
        is_built : boolean
            Is this function already existent within the root file
        node_ref : SegmentTreeNode
            The node representing this segment
        """
        self.is_built = is_built
        self.node_ref = node_ref

    def get_node(self):
        """Gets the node reference of the object

        Returns
        -------
        node_ref : SegmentTreeNode
            The segment tree node that represents the function
        """
        return self.node_ref

    def get_build_status(self):
        """Gets if the segment has been summed yet

        Returns
        -------
        build_status : bool
            True if the segment exists in the root file, false otherwise
        """
        return self.is_built


def gen_quartet_names(fmt_str, curr_segs, inds):
    """This function generates the 1 level of divisions down from what is
    passed to it

    Parameters
    ----------
    fmt_str : str
        The name generating format string
    curr_segs : int
        The segmentation at the current level
    inds : tuple
        A tuple of two integers holding the two current segment indices

    Returns
    -------
    seg_name_list : list of strings
        list of names of the 4 segments comprising the one passed to this func
    """
    seg_name_list = []
    off1 = 2*inds[0]
    off2 = 2*inds[1]
    for i in range(2):
        for j in range(2):
            seg_name_list.append(fmt_str.format(curr_segs*2,
                                                off1 + i, off2 + j))
    return seg_name_list
